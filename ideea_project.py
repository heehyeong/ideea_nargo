# -*- coding: utf-8 -*-
"""IDEEA_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bhQXE84WOEhWG84HSE_syjo3Z7NkXJpr

## 모듈 불러오기
"""

!pip install requests
!pip install folium
!pip install pulp
!pip install gurobipy

import requests
import pandas as pd
import numpy as np
import itertools

import json
import re

import folium

import copy

from pulp import LpProblem, LpMaximize, LpVariable, LpInteger, LpBinary, lpSum, value
from sklearn.preprocessing import RobustScaler

from gurobipy import Model, GRB, quicksum
import gurobipy as gp

import matplotlib.pyplot as plt

"""## 데이터 로드

1. 주유소 위치 데이터 (후보지)
"""

candidate = pd.read_excel('/content/서울시 주유소 현황 위도 경도 버전.xlsx')

candidate

"""카카오맵 앱키: 96dec8bae657de442ec7e2e85f309ae8

2. 교통량 데이터 (통행량)
"""

amount = pd.read_excel('/content/05월 서울시 교통량 조사자료(2024).xlsx', sheet_name=1)
amount

# 0시부터 23시까지의 열을 모두 더하여 총교통량 열을 생성
hour_columns = [f'{hour}시' for hour in range(24)]
amount['총교통량'] = amount[hour_columns].sum(axis=1)

# 지점번호별로 그룹핑하여 총교통량의 평균을 계산
average_traffic = amount.groupby('지점번호')['총교통량'].mean().reset_index()
average_traffic.columns = ['지점번호', '교통량']

# 원래 데이터프레임에 병합하여 교통량 열 추가
amount = amount.merge(average_traffic, on='지점번호', how='left')

# 불필요한 열 삭제 (선택 사항, 필요에 따라 삭제하지 않아도 됨)
amount.drop(columns=['총교통량'] + hour_columns, inplace=True)

amount

"""3. 주유소 - 교통량 연결"""

road = pd.read_excel('/content/05월 서울시 교통량 조사자료(2024).xlsx', sheet_name=2)
road

# 유클리디안 거리 계산 함수
def calculate_distance(lat1, lon1, lat2, lon2):
    return np.sqrt((lat1 - lat2)**2 + (lon1 - lon2)**2)

# 가장 가까운 지점 번호를 찾는 함수
def find_closest_station(row, road_df):
    distances = road_df.apply(lambda x: calculate_distance(row['Latitude'], row['Longitude'], x['위도'], x['경도']), axis=1)
    closest_idx = distances.idxmin()
    return road_df.loc[closest_idx, '지점번호']

# 각 candidate의 위치와 가장 가까운 road 지점을 찾아 새로운 컬럼 추가
candidate['가장_가까운_지점'] = candidate.apply(find_closest_station, axis=1, road_df=road)
candidate

"""**candidate 컬럼에 모두 저장**"""

# candidate 데이터프레임에 교통량(n_i)을 추가
# candidate = candidate.merge(amount[['지점번호', '교통량']], left_on='가장_가까운_지점', right_on='지점번호', how='left')
# candidate.rename(columns={'교통량': 'n_i'}, inplace=True)
# candidate.drop(columns=['지점번호'], inplace=True)
candidate = candidate.drop_duplicates()

candidate

"""4. 행정구역 관련 definition (필요하면 추가할 것)
    - 강북_서(1): 은평구, 서대문구, 마포구, 종로구, 중구, 용산구
    - 강북_동(2): 성북구, 강북구, 도봉구, 노원구, 중랑구, 동대문구, 성동구, 광진구
    - 강남_서(3): 강서구, 양천구, 구로구, 영등포구, 동장구, 관악구, 금천구
    - 강남_동(4): 서초구, 강남구, 송파구, 강동구
"""

cand_1=['은평구', '서대문구','마포구', '종로구', '중구', '용산구']
cand_2=['성북구', '강북구', '도봉구', '노원구', '중랑구', '동대문구', '성동구', '광진구']
cand_3=['강서구', '양천구', '구로구', '영등포구', '동작구', '관악구', '금천구']
cand_4=['서초구', '강남구', '송파구', '강동구']

# 'Y_ij' 열을 초기화
candidate['Y_ij'] = None

# 반복문을 사용하여 'Y_ij' 열 업데이트
for i, cand_list in enumerate([cand_1, cand_2, cand_3, cand_4], start=1):
    candidate.loc[candidate['자치구명'].isin(cand_list), 'Y_ij'] = i

print(candidate)

# candidate 데이터프레임에 교통량(n_i)을 추가
candidate = candidate.merge(amount[['지점번호', '교통량']], left_on='가장_가까운_지점', right_on='지점번호', how='left')
candidate.rename(columns={'교통량': 'n_i'}, inplace=True)
candidate.drop(columns=['지점번호'], inplace=True)

candidate

# candidate 데이터프레임에서 중복 행 제거
candidate = candidate.drop_duplicates()

# 또는 특정 열을 기준으로 중복 제거
# 예: '가장_가까운_지점' 열을 기준으로 중복 제거
# candidate = candidate.drop_duplicates(subset=['가장_가까운_지점'])

candidate

candidate.to_csv('최종 데이터.csv')

df = pd.read_csv('최종 데이터.csv')
df

# n_i 열에서 값이 0인 개수 확인
zero_count_n_i = (candidate['n_i'] == 0).sum()

# 0인 값의 개수 출력
print(f"n_i 열에 값이 0인 개수: {zero_count_n_i}")

# n_i 열에서 값이 0인 행을 삭제
candidate = candidate[candidate['n_i'] != 0]

candidate

"""## 시각화"""

# 지도의 중심 설정
target_id = 1
target_row = df[df['연번'] == target_id]
latitude = target_row['Latitude'].values[0]
longitude = target_row['Longitude'].values[0]

# 초기 지도 설정
# location : 초기 지도의 중심 위치 / zoom_start : 초기 줌 레벨을 설정, 값이 클수록 더 확대
map = folium.Map(location=[latitude, longitude], zoom_start=13, tiles='OpenStreetMap')

# 데이터프레임의 각 행에 대해 위에 형성된 지도에 마커 추가
# location : 마커의 위치 / popup : 지도를 클릭했을 때의 텍스트 설정 / tooltip : 마커 위에 마우스를 올렸을 때의 텍스트 설정
for idx, row in df.iterrows():
    folium.Marker(
        location = [row['Latitude'], row['Longitude']],
        popup = row['주소'],
        tooltip = row['연번'],
        icon = folium.Icon(color='red')
    ).add_to(map)

# 지도 출력 (Jupyter Notebook에서만 동작)
map

"""## 최적화"""

import pulp

n = df['n_i']  # 각 후보지의 통행량 (예시 데이터)
num_sites = len(n)
num_install = 4  # 설치할 거점 수

# 문제 정의
problem = pulp.LpProblem("Minimize_Traffic_Flow", pulp.LpMinimize)
# 변수 정의
x = [pulp.LpVariable(f"x_{i}", cat='Binary') for i in range(num_sites)]
# 목적 함수
problem += pulp.lpSum(n[i] * x[i] for i in range(num_sites))
# 제약 조건
problem += pulp.lpSum(x) == num_install, "Total_Installations"
# 문제 해결
problem.solve()
# 결과 출력
installed_sites = [i for i in range(num_sites) if pulp.value(x[i]) == 1]
total_traffic_flow = pulp.value(problem.objective)
# 설치된 거점의 정보만 포함하는 데이터프레임 생성
df_optimized = df[df.index.isin(installed_sitess)]
df_optimized

# print("설치된 거점:", installed_sites)
# print("최소 총 통행량:", total_traffic_flow)

# 설치된 거점 목록
installed_points = [0, 2, 198, 326]

# 설치된 거점의 정보만 포함하는 데이터프레임 생성
df_optimized = df[df.index.isin(installed_points)]

df_optimized

# 지도의 중심 설정
target_id = 1
target_row = df[df['연번'] == target_id]
latitude = target_row['Latitude'].values[0]
longitude = target_row['Longitude'].values[0]

# 초기 지도 설정
# location : 초기 지도의 중심 위치 / zoom_start : 초기 줌 레벨을 설정, 값이 클수록 더 확대
map = folium.Map(location=[latitude, longitude], zoom_start=13, tiles='CartoDB Positron')

# 데이터프레임의 각 행에 대해 위에 형성된 지도에 마커 추가
# location : 마커의 위치 / popup : 지도를 클릭했을 때의 텍스트 설정 / tooltip : 마커 위에 마우스를 올렸을 때의 텍스트 설정
for idx, row in df_optimized.iterrows():
    folium.Marker(
        location = [row['Latitude'], row['Longitude']],
        popup = row['주소'],
        tooltip = row['연번'],
        icon = folium.Icon(color='red')
    ).add_to(map)

# 지도 출력 (Jupyter Notebook에서만 동작)
map

"""## 최적화 (2)

decision variable 추가
"""

Y_ij = df['Y_ij']

# Problem Definition
problem = pulp.LpProblem("Minimize_Traffic_Flow", pulp.LpMinimize)
# Decision variable Definition
x = [pulp.LpVariable(f"x_{i}", cat='Binary') for i in range(num_sites)]
# Objective Function
problem += pulp.lpSum(n[i] * x[i] for i in range(num_sites))
# Constraint 1: Only 4 centers should be selected
problem += pulp.lpSum(x) == num_install, "Total_Installations"
# Constraint 2: Each region[j] has to be covered by 1 center / Each center have to be well seperated
for j in set(Y_ij):
    indices = [i for i, value in enumerate(Y_ij) if value == j]
    problem += pulp.lpSum(x[i] for i in indices) == 1, f"Y_ij_{j}_Constraint"
# Solving the problem
problem.solve()
# 결과 출력
installed_sites = [i for i in range(num_sites) if pulp.value(x[i]) == 1]
total_traffic_flow = pulp.value(problem.objective)
# 설치된 거점의 정보만 포함하는 데이터프레임 생성
df_optimized = df[df.index.isin(installed_sites)]

# print("설치된 거점:", installed_sites)
# print("최소 총 통행량:", total_traffic_flow)

# 설치된 거점 목록
installed_points = [2,44,198,255]

# 설치된 거점의 정보만 포함하는 데이터프레임 생성
df_optimized_2 = df[df.index.isin(installed_points)]

df_optimized_2

# 지도의 중심 설정
target_id = 1
target_row = df[df['연번'] == target_id]
latitude = target_row['Latitude'].values[0]
longitude = target_row['Longitude'].values[0]

# 초기 지도 설정
# location : 초기 지도의 중심 위치 / zoom_start : 초기 줌 레벨을 설정, 값이 클수록 더 확대
map = folium.Map(location=[latitude, longitude], zoom_start=13)

# 데이터프레임의 각 행에 대해 위에 형성된 지도에 마커 추가
# location : 마커의 위치 / popup : 지도를 클릭했을 때의 텍스트 설정 / tooltip : 마커 위에 마우스를 올렸을 때의 텍스트 설정
for idx, row in df_optimized_2.iterrows():
    folium.Marker(
        location = [row['Latitude'], row['Longitude']],
        popup = row['주소'],
        tooltip = row['연번'],
        icon = folium.Icon(color='red')
    ).add_to(map)

# 지도 출력 (Jupyter Notebook에서만 동작)
map

import folium
import json

# 초기 지도 설정
map = folium.Map(location=[37.5665, 126.9780], zoom_start=11, tiles='CartoDB Positron')

# GeoJSON 파일 로드 (서울시 구역 경계)
geo_json_data = json.load(open('seoul_municipalities_geo.json', encoding='utf-8'))

# 구역별 스타일 설정
def style_function(feature):
    district = feature['properties']['SIG_KOR_NM']
    color = 'blue'  # 기본 색상 설정
    if district in district_1:
        color = 'gray'
    elif district in district_2:
        color = 'skyblue'
    elif district in district_3:
        color = 'pink'
    elif district in district_4:
        color = 'green'

    return {
        'fillColor': color,
        'color': 'black',  # 경계선 색상
        'weight': 0.5,       # 경계선 두께
        'fillOpacity': 0.5  # 채우기의 투명도
    }

# GeoJSON을 지도에 추가
folium.GeoJson(
    geo_json_data,
    style_function=style_function
).add_to(map)

# 데이터프레임의 각 행에 대해 마커 추가
for idx, row in df_optimized_2.iterrows():
    folium.Marker(
        location=[row['Latitude'], row['Longitude']],
        popup=row['주소'],
        tooltip=row['연번'],
        icon=folium.Icon(color='red')
    ).add_to(map)

# 지도 출력 (Jupyter Notebook에서만 동작)
map

df_optimized_2.to_csv('Final hub.csv')

ev = pd.read_csv('/content/서울시 자치구별 전기차 용도별 등록현황(2017~2022년).csv', encoding ='cp949')
ev

ev_day = ev[ev['연월별']== '2022-07-31']
ev_day

"""cand_1=['은평구', '서대문구','마포구', '종로구', '중구', '용산구']

cand_2=['성북구', '강북구', '도봉구', '노원구', '중랑구', '동대문구', '성동구', '광진구']

cand_3=['강서구', '양천구', '구로구', '영등포구', '동작구', '관악구', '금천구']

cand_4=['서초구', '강남구', '송파구', '강동구']
"""

# Define district groups
district_1 = ['은평구', '서대문구', '마포구', '종로구', '중구', '용산구']
district_2 = ['성북구', '강북구', '도봉구', '노원구', '중랑구', '동대문구', '성동구', '광진구']
district_3 = ['강서구', '양천구', '구로구', '영등포구', '동작구', '관악구', '금천구']
district_4 = ['서초구', '강남구', '송파구', '강동구']

# Function to calculate sum for a candidate group
def calculate_sum(candidate_list):
    return ev_day[ev_day['시군구별'].isin(candidate_list)]['계'].sum()

# Calculate sums for each candidate group
sum_district_1 = calculate_sum(cand_1)
sum_district_2 = calculate_sum(cand_2)
sum_district_3 = calculate_sum(cand_3)
sum_district_4 = calculate_sum(cand_4)

# 전기차 대수 지역별 합계
# Create a DataFrame to store the results
results = pd.DataFrame({
    'district': ['district_1', 'district_2', 'district_3', 'district_4'],
    'EVs': [sum_district_1, sum_district_2, sum_district_3, sum_district_4]
})

results

def calculate_sum_2(candidate_list):
    return df[df['자치구명'].isin(candidate_list)]['n_i'].sum()

# Calculate sums for each candidate group
sum_district_1 = calculate_sum_2(cand_1)
sum_district_2 = calculate_sum_2(cand_2)
sum_district_3 = calculate_sum_2(cand_3)
sum_district_4 = calculate_sum_2(cand_4)

#통행량 지역별 합계
road_results = pd.DataFrame({
    'district': ['district_1', 'district_2', 'district_3', 'district_4'],
    'Traffic/day': [sum_district_1, sum_district_2, sum_district_3, sum_district_4]
})

road_results

results = results.merge(amount['EVs'], left_on='district', how='left')

